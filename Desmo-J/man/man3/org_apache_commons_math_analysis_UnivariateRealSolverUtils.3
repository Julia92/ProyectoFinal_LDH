.TH "org.apache.commons.math.analysis.UnivariateRealSolverUtils" 3 "Wed Dec 4 2013" "Version 1.0" "Desmo-J" \" -*- nroff -*-
.ad l
.nh
.SH NAME
org.apache.commons.math.analysis.UnivariateRealSolverUtils \- 
.SH SYNOPSIS
.br
.PP
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static double \fBsolve\fP (\fBUnivariateRealFunction\fP f, double x0, double x1)  throws ConvergenceException, FunctionEvaluationException "
.br
.ti -1c
.RI "static double \fBsolve\fP (\fBUnivariateRealFunction\fP f, double x0, double x1, double absoluteAccuracy)  throws ConvergenceException,              FunctionEvaluationException "
.br
.ti -1c
.RI "static double[] \fBbracket\fP (\fBUnivariateRealFunction\fP function, double initial, double lowerBound, double upperBound)  throws ConvergenceException, FunctionEvaluationException "
.br
.ti -1c
.RI "static double[] \fBbracket\fP (\fBUnivariateRealFunction\fP function, double initial, double lowerBound, double upperBound, int maximumIterations)  throws ConvergenceException,              FunctionEvaluationException "
.br
.ti -1c
.RI "static double \fBmidpoint\fP (double a, double b)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Utility routines for \fBUnivariateRealSolver\fP objects\&.
.PP
\fBVersion:\fP
.RS 4
.RE
.PP
\fBRevision:\fP
.RS 4
615734 
.RE
.PP
\fBDate:\fP
.RS 4
2008-01-27 23:10:03 -0700 (Sun, 27 Jan 2008) 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "static double [] org\&.apache\&.commons\&.math\&.analysis\&.UnivariateRealSolverUtils\&.bracket (\fBUnivariateRealFunction\fPfunction, doubleinitial, doublelowerBound, doubleupperBound) throws \fBConvergenceException\fP, \fBFunctionEvaluationException\fP\fC [static]\fP"
This method attempts to find two values a and b satisfying 
.PD 0

.IP "\(bu" 2
\fC lowerBound <= a < initial < b <= upperBound\fP  
.IP "\(bu" 2
\fC f(a) * f(b) < 0 \fP 
.PP
If f is continuous on \fC[a,b],\fP this means that \fCa\fP and \fCb\fP bracket a root of f\&. 
.PP
The algorithm starts by setting \fCa := initial -1; b := initial +1,\fP examines the value of the function at \fCa\fP and \fCb\fP and keeps moving the endpoints out by one unit each time through a loop that terminates when one of the following happens: 
.PD 0

.IP "\(bu" 2
\fC f(a) * f(b) < 0 \fP -- success! 
.IP "\(bu" 2
\fC a = lower \fP and \fC b = upper\fP -- \fBConvergenceException\fP  
.IP "\(bu" 2
\fC Integer\&.MAX_VALUE\fP iterations elapse -- \fBConvergenceException\fP  
.PP
.PP
\fBNote: \fP this method can take \fCInteger\&.MAX_VALUE\fP iterations to throw a \fC\fBConvergenceException\fP\&.\fP Unless you are confident that there is a root between \fClowerBound\fP and \fCupperBound\fP near \fCinitial,\fP it is better to use \fBbracket(UnivariateRealFunction, double, double, double, int)\fP, explicitly specifying the maximum number of iterations\&.
.PP
\fBParameters:\fP
.RS 4
\fIfunction\fP the function 
.br
\fIinitial\fP initial midpoint of interval being expanded to bracket a root 
.br
\fIlowerBound\fP lower bound (a is never lower than this value) 
.br
\fIupperBound\fP upper bound (b never is greater than this value) 
.RE
.PP
\fBReturns:\fP
.RS 4
a two element array holding {a, b} 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBConvergenceException\fP\fP if a root can not be bracketted 
.br
\fI\fBFunctionEvaluationException\fP\fP if an error occurs evaluating the function 
.br
\fIIllegalArgumentException\fP if function is null, maximumIterations is not positive, or initial is not between lowerBound and upperBound 
.RE
.PP

.SS "static double [] org\&.apache\&.commons\&.math\&.analysis\&.UnivariateRealSolverUtils\&.bracket (\fBUnivariateRealFunction\fPfunction, doubleinitial, doublelowerBound, doubleupperBound, intmaximumIterations) throws \fBConvergenceException\fP,              \fBFunctionEvaluationException\fP\fC [static]\fP"
This method attempts to find two values a and b satisfying 
.PD 0

.IP "\(bu" 2
\fC lowerBound <= a < initial < b <= upperBound\fP  
.IP "\(bu" 2
\fC f(a) * f(b) < 0 \fP  
.PP
If f is continuous on \fC[a,b],\fP this means that \fCa\fP and \fCb\fP bracket a root of f\&. 
.PP
The algorithm starts by setting \fCa := initial -1; b := initial +1,\fP examines the value of the function at \fCa\fP and \fCb\fP and keeps moving the endpoints out by one unit each time through a loop that terminates when one of the following happens: 
.PD 0

.IP "\(bu" 2
\fC f(a) * f(b) < 0 \fP -- success! 
.IP "\(bu" 2
\fC a = lower \fP and \fC b = upper\fP -- \fBConvergenceException\fP  
.IP "\(bu" 2
\fC maximumIterations\fP iterations elapse -- \fBConvergenceException\fP 
.PP
.PP
\fBParameters:\fP
.RS 4
\fIfunction\fP the function 
.br
\fIinitial\fP initial midpoint of interval being expanded to bracket a root 
.br
\fIlowerBound\fP lower bound (a is never lower than this value) 
.br
\fIupperBound\fP upper bound (b never is greater than this value) 
.br
\fImaximumIterations\fP maximum number of iterations to perform 
.RE
.PP
\fBReturns:\fP
.RS 4
a two element array holding {a, b}\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBConvergenceException\fP\fP if the algorithm fails to find a and b satisfying the desired conditions 
.br
\fI\fBFunctionEvaluationException\fP\fP if an error occurs evaluating the function 
.br
\fIIllegalArgumentException\fP if function is null, maximumIterations is not positive, or initial is not between lowerBound and upperBound 
.RE
.PP

.SS "static double org\&.apache\&.commons\&.math\&.analysis\&.UnivariateRealSolverUtils\&.midpoint (doublea, doubleb)\fC [static]\fP"
Compute the midpoint of two values\&.
.PP
\fBParameters:\fP
.RS 4
\fIa\fP first value\&. 
.br
\fIb\fP second value\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the midpoint\&. 
.RE
.PP

.SS "static double org\&.apache\&.commons\&.math\&.analysis\&.UnivariateRealSolverUtils\&.solve (\fBUnivariateRealFunction\fPf, doublex0, doublex1) throws \fBConvergenceException\fP, \fBFunctionEvaluationException\fP\fC [static]\fP"
Convenience method to find a zero of a univariate real function\&. A default solver is used\&.
.PP
\fBParameters:\fP
.RS 4
\fIf\fP the function\&. 
.br
\fIx0\fP the lower bound for the interval\&. 
.br
\fIx1\fP the upper bound for the interval\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
a value where the function is zero\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBConvergenceException\fP\fP if the iteration count was exceeded 
.br
\fI\fBFunctionEvaluationException\fP\fP if an error occurs evaluating the function 
.br
\fIIllegalArgumentException\fP if f is null or the endpoints do not specify a valid interval 
.RE
.PP

.SS "static double org\&.apache\&.commons\&.math\&.analysis\&.UnivariateRealSolverUtils\&.solve (\fBUnivariateRealFunction\fPf, doublex0, doublex1, doubleabsoluteAccuracy) throws \fBConvergenceException\fP,              \fBFunctionEvaluationException\fP\fC [static]\fP"
Convenience method to find a zero of a univariate real function\&. A default solver is used\&.
.PP
\fBParameters:\fP
.RS 4
\fIf\fP the function 
.br
\fIx0\fP the lower bound for the interval 
.br
\fIx1\fP the upper bound for the interval 
.br
\fIabsoluteAccuracy\fP the accuracy to be used by the solver 
.RE
.PP
\fBReturns:\fP
.RS 4
a value where the function is zero 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBConvergenceException\fP\fP if the iteration count is exceeded 
.br
\fI\fBFunctionEvaluationException\fP\fP if an error occurs evaluating the function 
.br
\fIIllegalArgumentException\fP if f is null, the endpoints do not specify a valid interval, or the absoluteAccuracy is not valid for the default solver 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Desmo-J from the source code\&.
