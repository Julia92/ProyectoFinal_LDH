.TH "org.apache.commons.collections.map.AbstractReferenceMap" 3 "Wed Dec 4 2013" "Version 1.0" "Desmo-J" \" -*- nroff -*-
.ad l
.nh
.SH NAME
org.apache.commons.collections.map.AbstractReferenceMap \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBorg\&.apache\&.commons\&.collections\&.map\&.AbstractHashedMap\fP\&.
.PP
Inherited by \fBorg\&.apache\&.commons\&.collections\&.map\&.ReferenceMap\fP, and \fBorg\&.apache\&.commons\&.collections\&.map\&.ReferenceMapGeneric\fP\&.
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBReferenceEntry\fP"
.br
.ti -1c
.RI "class \fBReferenceEntrySet\fP"
.br
.ti -1c
.RI "class \fBReferenceEntrySetIterator\fP"
.br
.ti -1c
.RI "class \fBReferenceKeySet\fP"
.br
.ti -1c
.RI "class \fBReferenceKeySetIterator\fP"
.br
.ti -1c
.RI "class \fBReferenceMapIterator\fP"
.br
.ti -1c
.RI "class \fBReferenceValues\fP"
.br
.ti -1c
.RI "class \fBReferenceValuesIterator\fP"
.br
.ti -1c
.RI "class \fBSoftRef\fP"
.br
.ti -1c
.RI "class \fBWeakRef\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "int \fBsize\fP ()"
.br
.ti -1c
.RI "boolean \fBisEmpty\fP ()"
.br
.ti -1c
.RI "boolean \fBcontainsKey\fP (Object key)"
.br
.ti -1c
.RI "boolean \fBcontainsValue\fP (Object value)"
.br
.ti -1c
.RI "Object \fBget\fP (Object key)"
.br
.ti -1c
.RI "Object \fBput\fP (Object key, Object value)"
.br
.ti -1c
.RI "Object \fBremove\fP (Object key)"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "\fBMapIterator\fP \fBmapIterator\fP ()"
.br
.ti -1c
.RI "Set \fBentrySet\fP ()"
.br
.ti -1c
.RI "Set \fBkeySet\fP ()"
.br
.ti -1c
.RI "Collection \fBvalues\fP ()"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static final int \fBHARD\fP = 0"
.br
.ti -1c
.RI "static final int \fBSOFT\fP = 1"
.br
.ti -1c
.RI "static final int \fBWEAK\fP = 2"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBAbstractReferenceMap\fP ()"
.br
.ti -1c
.RI "\fBAbstractReferenceMap\fP (int \fBkeyType\fP, int \fBvalueType\fP, int capacity, float \fBloadFactor\fP, boolean \fBpurgeValues\fP)"
.br
.ti -1c
.RI "void \fBinit\fP ()"
.br
.ti -1c
.RI "void \fBpurgeBeforeRead\fP ()"
.br
.ti -1c
.RI "void \fBpurgeBeforeWrite\fP ()"
.br
.ti -1c
.RI "void \fBpurge\fP ()"
.br
.ti -1c
.RI "void \fBpurge\fP (Reference ref)"
.br
.ti -1c
.RI "HashEntry \fBgetEntry\fP (Object key)"
.br
.ti -1c
.RI "int \fBhashEntry\fP (Object key, Object value)"
.br
.ti -1c
.RI "boolean \fBisEqualKey\fP (Object key1, Object key2)"
.br
.ti -1c
.RI "HashEntry \fBcreateEntry\fP (HashEntry next, int \fBhashCode\fP, Object key, Object value)"
.br
.ti -1c
.RI "Iterator \fBcreateEntrySetIterator\fP ()"
.br
.ti -1c
.RI "Iterator \fBcreateKeySetIterator\fP ()"
.br
.ti -1c
.RI "Iterator \fBcreateValuesIterator\fP ()"
.br
.ti -1c
.RI "void \fBdoWriteObject\fP (ObjectOutputStream out)  throws IOException "
.br
.ti -1c
.RI "void \fBdoReadObject\fP (ObjectInputStream in)  throws IOException, ClassNotFoundException "
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "int \fBkeyType\fP"
.br
.ti -1c
.RI "int \fBvalueType\fP"
.br
.ti -1c
.RI "boolean \fBpurgeValues\fP"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
An abstract implementation of a hash-based map that allows the entries to be removed by the garbage collector\&. 
.PP
This class implements all the features necessary for a subclass reference hash-based map\&. Key-value entries are stored in instances of the \fCReferenceEntry\fP class which can be overridden and replaced\&. The iterators can similarly be replaced, without the need to replace the KeySet, EntrySet and Values view classes\&. 
.PP
Overridable methods are provided to change the default hashing behaviour, and to change how entries are added to and removed from the map\&. Hopefully, all you need for unusual subclasses is here\&. 
.PP
When you construct an \fC\fBAbstractReferenceMap\fP\fP, you can specify what kind of references are used to store the map's keys and values\&. If non-hard references are used, then the garbage collector can remove mappings if a key or value becomes unreachable, or if the JVM's memory is running low\&. For information on how the different reference types behave, see \fBReference\fP\&. 
.PP
Different types of references can be specified for keys and values\&. The keys can be configured to be weak but the values hard, in which case this class will behave like a \fC\fCWeakHashMap\fP\fP\&. However, you can also specify hard keys and weak values, or any other combination\&. The default constructor uses hard keys and soft values, providing a memory-sensitive cache\&. 
.PP
This \fBMap\fP implementation does \fInot\fP allow null elements\&. Attempting to add a null key or value to the map will raise a \fCNullPointerException\fP\&. 
.PP
All the available iterators can be reset back to the start by casting to \fC\fBResettableIterator\fP\fP and calling \fCreset()\fP\&. 
.PP
This implementation is not synchronized\&. You can use \fBjava\&.util\&.Collections#synchronizedMap\fP to provide synchronized access to a \fC\fBReferenceMap\fP\fP\&.
.PP
\fBSee Also:\fP
.RS 4
java\&.lang\&.ref\&.Reference 
.RE
.PP
\fBSince:\fP
.RS 4
Commons Collections 3\&.1 (extracted from \fBReferenceMap\fP in 3\&.0) 
.RE
.PP
\fBVersion:\fP
.RS 4
.RE
.PP
\fBRevision:\fP
.RS 4
646777 
.RE
.PP
\fBDate:\fP
.RS 4
2008-04-10 13:33:15 +0100 (Thu, 10 Apr 2008) 
.RE
.PP
.PP
\fBAuthor:\fP
.RS 4
Paul Jack 
.PP
Stephen Colebourne 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.AbstractReferenceMap ()\fC [protected]\fP"
Constructor used during deserialization\&. 
.SS "org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.AbstractReferenceMap (intkeyType, intvalueType, intcapacity, floatloadFactor, booleanpurgeValues)\fC [protected]\fP"
Constructs a new empty map with the specified reference types, load factor and initial capacity\&.
.PP
\fBParameters:\fP
.RS 4
\fIkeyType\fP the type of reference to use for keys; must be \fBHARD\fP, \fBSOFT\fP, \fBWEAK\fP 
.br
\fIvalueType\fP the type of reference to use for values; must be \fBHARD\fP, \fBSOFT\fP, \fBWEAK\fP 
.br
\fIcapacity\fP the initial capacity for the map 
.br
\fIloadFactor\fP the load factor for the map 
.br
\fIpurgeValues\fP should the value be automatically purged when the key is garbage collected 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "void org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.clear ()"
Clears this map\&. 
.SS "boolean org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.containsKey (Objectkey)"
Checks whether the map contains the specified key\&.
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP the key to search for 
.RE
.PP
\fBReturns:\fP
.RS 4
true if the map contains the key 
.RE
.PP

.SS "boolean org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.containsValue (Objectvalue)"
Checks whether the map contains the specified value\&.
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP the value to search for 
.RE
.PP
\fBReturns:\fP
.RS 4
true if the map contains the value 
.RE
.PP

.SS "HashEntry org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.createEntry (HashEntrynext, inthashCode, Objectkey, Objectvalue)\fC [protected]\fP"
Creates a ReferenceEntry instead of a HashEntry\&.
.PP
\fBParameters:\fP
.RS 4
\fInext\fP the next entry in sequence 
.br
\fIhashCode\fP the hash code to use 
.br
\fIkey\fP the key to store 
.br
\fIvalue\fP the value to store 
.RE
.PP
\fBReturns:\fP
.RS 4
the newly created entry 
.RE
.PP

.SS "Iterator org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.createEntrySetIterator ()\fC [protected]\fP"
Creates an entry set iterator\&.
.PP
\fBReturns:\fP
.RS 4
the entrySet iterator 
.RE
.PP

.SS "Iterator org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.createKeySetIterator ()\fC [protected]\fP"
Creates an key set iterator\&.
.PP
\fBReturns:\fP
.RS 4
the keySet iterator 
.RE
.PP

.SS "Iterator org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.createValuesIterator ()\fC [protected]\fP"
Creates an values iterator\&.
.PP
\fBReturns:\fP
.RS 4
the values iterator 
.RE
.PP

.SS "void org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.doReadObject (ObjectInputStreamin) throws IOException, ClassNotFoundException\fC [protected]\fP"
Replaces the superclassm method to read the state of this class\&. 
.PP
Serialization is not one of the JDK's nicest topics\&. Normal serialization will initialise the superclass before the subclass\&. Sometimes however, this isn't what you want, as in this case the \fC\fBput()\fP\fP method on read can be affected by subclass state\&. 
.PP
The solution adopted here is to deserialize the state data of this class in this protected method\&. This method must be called by the \fCreadObject()\fP of the first serializable subclass\&. 
.PP
Subclasses may override if the subclass has a specific field that must be present before \fC\fBput()\fP\fP or \fC\fBcalculateThreshold()\fP\fP will work correctly\&.
.PP
\fBParameters:\fP
.RS 4
\fIin\fP the input stream 
.RE
.PP

.SS "void org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.doWriteObject (ObjectOutputStreamout) throws IOException\fC [protected]\fP"
Replaces the superclass method to store the state of this class\&. 
.PP
Serialization is not one of the JDK's nicest topics\&. Normal serialization will initialise the superclass before the subclass\&. Sometimes however, this isn't what you want, as in this case the \fC\fBput()\fP\fP method on read can be affected by subclass state\&. 
.PP
The solution adopted here is to serialize the state data of this class in this protected method\&. This method must be called by the \fCwriteObject()\fP of the first serializable subclass\&. 
.PP
Subclasses may override if they have a specific field that must be present on read before this implementation will work\&. Generally, the read determines what must be serialized here, if anything\&.
.PP
\fBParameters:\fP
.RS 4
\fIout\fP the output stream 
.RE
.PP

.SS "Set org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.entrySet ()"
Returns a set view of this map's entries\&. An iterator returned entry is valid until \fCnext()\fP is called again\&. The \fCsetValue()\fP method on the \fCtoArray\fP entries has no effect\&.
.PP
\fBReturns:\fP
.RS 4
a set view of this map's entries 
.RE
.PP

.SS "Object org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.get (Objectkey)"
Gets the value mapped to the key specified\&.
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP the key 
.RE
.PP
\fBReturns:\fP
.RS 4
the mapped value, null if no match 
.RE
.PP

.SS "HashEntry org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.getEntry (Objectkey)\fC [protected]\fP"
Gets the entry mapped to the key specified\&.
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP the key 
.RE
.PP
\fBReturns:\fP
.RS 4
the entry, null if no match 
.RE
.PP

.SS "int org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.hashEntry (Objectkey, Objectvalue)\fC [protected]\fP"
Gets the hash code for a MapEntry\&. Subclasses can override this, for example to use the identityHashCode\&.
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP the key to get a hash code for, may be null 
.br
\fIvalue\fP the value to get a hash code for, may be null 
.RE
.PP
\fBReturns:\fP
.RS 4
the hash code, as per the MapEntry specification 
.RE
.PP

.SS "void org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.init ()\fC [protected]\fP"
Initialise this subclass during construction, cloning or deserialization\&. 
.SS "boolean org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.isEmpty ()"
Checks whether the map is currently empty\&.
.PP
\fBReturns:\fP
.RS 4
true if the map is currently size zero 
.RE
.PP

.SS "boolean org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.isEqualKey (Objectkey1, Objectkey2)\fC [protected]\fP"
Compares two keys, in internal converted form, to see if they are equal\&. 
.PP
This implementation converts the key from the entry to a real reference before comparison\&.
.PP
\fBParameters:\fP
.RS 4
\fIkey1\fP the first key to compare passed in from outside 
.br
\fIkey2\fP the second key extracted from the entry via \fCentry\&.key\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
true if equal 
.RE
.PP

.SS "Set org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.keySet ()"
Returns a set view of this map's keys\&.
.PP
\fBReturns:\fP
.RS 4
a set view of this map's keys 
.RE
.PP

.SS "\fBMapIterator\fP org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.mapIterator ()"
Gets a \fBMapIterator\fP over the reference map\&. The iterator only returns valid key/value pairs\&.
.PP
\fBReturns:\fP
.RS 4
a map iterator 
.RE
.PP

.PP
Implements \fBorg\&.apache\&.commons\&.collections\&.IterableMap\fP\&.
.SS "void org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.purge ()\fC [protected]\fP"
Purges stale mappings from this map\&. 
.PP
Note that this method is not synchronized! Special care must be taken if, for instance, you want stale mappings to be removed on a periodic basis by some background thread\&. 
.SS "void org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.purge (Referenceref)\fC [protected]\fP"
Purges the specified reference\&.
.PP
\fBParameters:\fP
.RS 4
\fIref\fP the reference to purge 
.RE
.PP

.SS "void org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.purgeBeforeRead ()\fC [protected]\fP"
Purges stale mappings from this map before read operations\&. 
.PP
This implementation calls \fBpurge()\fP to maintain a consistent state\&. 
.SS "void org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.purgeBeforeWrite ()\fC [protected]\fP"
Purges stale mappings from this map before write operations\&. 
.PP
This implementation calls \fBpurge()\fP to maintain a consistent state\&. 
.SS "Object org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.put (Objectkey, Objectvalue)"
Puts a key-value mapping into this map\&. Neither the key nor the value may be null\&.
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP the key to add, must not be null 
.br
\fIvalue\fP the value to add, must not be null 
.RE
.PP
\fBReturns:\fP
.RS 4
the value previously mapped to this key, null if none 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fINullPointerException\fP if either the key or value is null 
.RE
.PP

.SS "Object org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.remove (Objectkey)"
Removes the specified mapping from this map\&.
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP the mapping to remove 
.RE
.PP
\fBReturns:\fP
.RS 4
the value mapped to the removed key, null if key not in map 
.RE
.PP

.SS "int org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.size ()"
Gets the size of the map\&.
.PP
\fBReturns:\fP
.RS 4
the size 
.RE
.PP

.SS "Collection org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.values ()"
Returns a collection view of this map's values\&.
.PP
\fBReturns:\fP
.RS 4
a set view of this map's values 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "final int org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.HARD = 0\fC [static]\fP"
Constant indicating that hard references should be used 
.SS "int org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.keyType\fC [protected]\fP"
The reference type for keys\&. Must be HARD, SOFT, WEAK\&.  
.SS "boolean org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.purgeValues\fC [protected]\fP"
Should the value be automatically purged when the associated key has been collected? 
.SS "final int org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.SOFT = 1\fC [static]\fP"
Constant indicating that soft references should be used 
.SS "int org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.valueType\fC [protected]\fP"
The reference type for values\&. Must be HARD, SOFT, WEAK\&.  
.SS "final int org\&.apache\&.commons\&.collections\&.map\&.AbstractReferenceMap\&.WEAK = 2\fC [static]\fP"
Constant indicating that weak references should be used 

.SH "Author"
.PP 
Generated automatically by Doxygen for Desmo-J from the source code\&.
