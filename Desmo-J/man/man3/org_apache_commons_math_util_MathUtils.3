.TH "org.apache.commons.math.util.MathUtils" 3 "Wed Dec 4 2013" "Version 1.0" "Desmo-J" \" -*- nroff -*-
.ad l
.nh
.SH NAME
org.apache.commons.math.util.MathUtils \- 
.SH SYNOPSIS
.br
.PP
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static int \fBaddAndCheck\fP (int x, int y)"
.br
.ti -1c
.RI "static long \fBaddAndCheck\fP (long a, long b)"
.br
.ti -1c
.RI "static long \fBbinomialCoefficient\fP (final int n, final int k)"
.br
.ti -1c
.RI "static double \fBbinomialCoefficientDouble\fP (final int n, final int k)"
.br
.ti -1c
.RI "static double \fBbinomialCoefficientLog\fP (final int n, final int k)"
.br
.ti -1c
.RI "static double \fBcosh\fP (double x)"
.br
.ti -1c
.RI "static boolean \fBequals\fP (double x, double y)"
.br
.ti -1c
.RI "static boolean \fBequals\fP (double[] x, double[] y)"
.br
.ti -1c
.RI "static long \fBfactorial\fP (final int n)"
.br
.ti -1c
.RI "static double \fBfactorialDouble\fP (final int n)"
.br
.ti -1c
.RI "static double \fBfactorialLog\fP (final int n)"
.br
.ti -1c
.RI "static int \fBgcd\fP (int u, int v)"
.br
.ti -1c
.RI "static int \fBhash\fP (double value)"
.br
.ti -1c
.RI "static int \fBhash\fP (double[] value)"
.br
.ti -1c
.RI "static byte \fBindicator\fP (final byte x)"
.br
.ti -1c
.RI "static double \fBindicator\fP (final double x)"
.br
.ti -1c
.RI "static float \fBindicator\fP (final float x)"
.br
.ti -1c
.RI "static int \fBindicator\fP (final int x)"
.br
.ti -1c
.RI "static long \fBindicator\fP (final long x)"
.br
.ti -1c
.RI "static short \fBindicator\fP (final short x)"
.br
.ti -1c
.RI "static int \fBlcm\fP (int a, int b)"
.br
.ti -1c
.RI "static double \fBlog\fP (double base, double x)"
.br
.ti -1c
.RI "static int \fBmulAndCheck\fP (int x, int y)"
.br
.ti -1c
.RI "static long \fBmulAndCheck\fP (long a, long b)"
.br
.ti -1c
.RI "static double \fBnextAfter\fP (double d, double direction)"
.br
.ti -1c
.RI "static double \fBnormalizeAngle\fP (double a, double center)"
.br
.ti -1c
.RI "static double \fBround\fP (double x, int scale)"
.br
.ti -1c
.RI "static double \fBround\fP (double x, int scale, int roundingMethod)"
.br
.ti -1c
.RI "static float \fBround\fP (float x, int scale)"
.br
.ti -1c
.RI "static float \fBround\fP (float x, int scale, int roundingMethod)"
.br
.ti -1c
.RI "static byte \fBsign\fP (final byte x)"
.br
.ti -1c
.RI "static double \fBsign\fP (final double x)"
.br
.ti -1c
.RI "static float \fBsign\fP (final float x)"
.br
.ti -1c
.RI "static int \fBsign\fP (final int x)"
.br
.ti -1c
.RI "static long \fBsign\fP (final long x)"
.br
.ti -1c
.RI "static short \fBsign\fP (final short x)"
.br
.ti -1c
.RI "static double \fBsinh\fP (double x)"
.br
.ti -1c
.RI "static int \fBsubAndCheck\fP (int x, int y)"
.br
.ti -1c
.RI "static long \fBsubAndCheck\fP (long a, long b)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Some useful additions to the built-in functions in \fBMath\fP\&. 
.PP
\fBVersion:\fP
.RS 4

.RE
.PP
\fBRevision:\fP
.RS 4
620312 
.RE
.PP
\fBDate:\fP
.RS 4
2008-02-10 12:28:59 -0700 (Sun, 10 Feb 2008) 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "static int org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.addAndCheck (intx, inty)\fC [static]\fP"
Add two integers, checking for overflow\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP an addend 
.br
\fIy\fP an addend 
.RE
.PP
\fBReturns:\fP
.RS 4
the sum \fCx+y\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIArithmeticException\fP if the result can not be represented as an int 
.RE
.PP
\fBSince:\fP
.RS 4
1\&.1 
.RE
.PP

.SS "static long org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.addAndCheck (longa, longb)\fC [static]\fP"
Add two long integers, checking for overflow\&.
.PP
\fBParameters:\fP
.RS 4
\fIa\fP an addend 
.br
\fIb\fP an addend 
.RE
.PP
\fBReturns:\fP
.RS 4
the sum \fCa+b\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIArithmeticException\fP if the result can not be represented as an long 
.RE
.PP
\fBSince:\fP
.RS 4
1\&.2 
.RE
.PP

.SS "static long org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.binomialCoefficient (final intn, final intk)\fC [static]\fP"
Returns an exact representation of the \fCBinomial Coefficient\fP, '<code>n choose k</code>', the number of \fCk\fP-element subsets that can be selected from an \fCn\fP-element set\&. 
.PP
\fBPreconditions\fP: 
.PD 0

.IP "\(bu" 2
\fC0 <= k <= n \fP (otherwise \fCIllegalArgumentException\fP is thrown) 
.IP "\(bu" 2
The result is small enough to fit into a \fClong\fP\&. The largest value of \fCn\fP for which all coefficients are \fC < Long\&.MAX_VALUE\fP is 66\&. If the computed value exceeds \fCLong\&.MAX_VALUE\fP an \fCArithMeticException \fP is thrown\&. 
.PP
.PP
\fBParameters:\fP
.RS 4
\fIn\fP the size of the set 
.br
\fIk\fP the size of the subsets to be counted 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCn choose k\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIIllegalArgumentException\fP if preconditions are not met\&. 
.br
\fIArithmeticException\fP if the result is too large to be represented by a long integer\&. 
.RE
.PP

.SS "static double org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.binomialCoefficientDouble (final intn, final intk)\fC [static]\fP"
Returns a \fCdouble\fP representation of the \fCBinomial Coefficient\fP, '<code>n choose k</code>', the number of \fCk\fP-element subsets that can be selected from an \fCn\fP-element set\&. 
.PP
\fBPreconditions\fP: 
.PD 0

.IP "\(bu" 2
\fC0 <= k <= n \fP (otherwise \fCIllegalArgumentException\fP is thrown) 
.IP "\(bu" 2
The result is small enough to fit into a \fCdouble\fP\&. The largest value of \fCn\fP for which all coefficients are < Double\&.MAX_VALUE is 1029\&. If the computed value exceeds Double\&.MAX_VALUE, Double\&.POSITIVE_INFINITY is returned 
.PP
.PP
\fBParameters:\fP
.RS 4
\fIn\fP the size of the set 
.br
\fIk\fP the size of the subsets to be counted 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCn choose k\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIIllegalArgumentException\fP if preconditions are not met\&. 
.RE
.PP

.SS "static double org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.binomialCoefficientLog (final intn, final intk)\fC [static]\fP"
Returns the natural \fClog\fP of the \fCBinomial Coefficient\fP, '<code>n choose k</code>', the number of \fCk\fP-element subsets that can be selected from an \fCn\fP-element set\&. 
.PP
\fBPreconditions\fP: 
.PD 0

.IP "\(bu" 2
\fC0 <= k <= n \fP (otherwise \fCIllegalArgumentException\fP is thrown) 
.PP
.PP
\fBParameters:\fP
.RS 4
\fIn\fP the size of the set 
.br
\fIk\fP the size of the subsets to be counted 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCn choose k\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIIllegalArgumentException\fP if preconditions are not met\&. 
.RE
.PP

.SS "static double org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.cosh (doublex)\fC [static]\fP"
Returns the \fChyperbolic cosine\fP of x\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP double value for which to find the hyperbolic cosine 
.RE
.PP
\fBReturns:\fP
.RS 4
hyperbolic cosine of x 
.RE
.PP

.SS "static boolean org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.equals (doublex, doubley)\fC [static]\fP"
Returns true iff both arguments are NaN or neither is NaN and they are equal
.PP
\fBParameters:\fP
.RS 4
\fIx\fP first value 
.br
\fIy\fP second value 
.RE
.PP
\fBReturns:\fP
.RS 4
true if the values are equal or both are NaN 
.RE
.PP

.SS "static boolean org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.equals (double[]x, double[]y)\fC [static]\fP"
Returns true iff both arguments are null or have same dimensions and all their elements are \fBequals\fP
.PP
\fBParameters:\fP
.RS 4
\fIx\fP first array 
.br
\fIy\fP second array 
.RE
.PP
\fBReturns:\fP
.RS 4
true if the values are both null or have same dimension and equal elements 
.RE
.PP
\fBSince:\fP
.RS 4
1\&.2 
.RE
.PP

.SS "static long org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.factorial (final intn)\fC [static]\fP"
Returns n!\&. Shorthand for \fCn\fP \fCFactorial\fP, the product of the numbers \fC1,\&.\&.\&.,n\fP\&. 
.PP
\fBPreconditions\fP: 
.PD 0

.IP "\(bu" 2
\fCn >= 0\fP (otherwise \fCIllegalArgumentException\fP is thrown) 
.IP "\(bu" 2
The result is small enough to fit into a \fClong\fP\&. The largest value of \fCn\fP for which \fCn!\fP < Long\&.MAX_VALUE is 20\&. If the computed value exceeds \fCLong\&.MAX_VALUE\fP an \fCArithMeticException \fP is thrown\&. 
.PP
.PP
\fBParameters:\fP
.RS 4
\fIn\fP argument 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCn!\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIArithmeticException\fP if the result is too large to be represented by a long integer\&. 
.br
\fIIllegalArgumentException\fP if n < 0 
.RE
.PP

.SS "static double org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.factorialDouble (final intn)\fC [static]\fP"
Returns n!\&. Shorthand for \fCn\fP \fCFactorial\fP, the product of the numbers \fC1,\&.\&.\&.,n\fP as a \fCdouble\fP\&. 
.PP
\fBPreconditions\fP: 
.PD 0

.IP "\(bu" 2
\fCn >= 0\fP (otherwise \fCIllegalArgumentException\fP is thrown) 
.IP "\(bu" 2
The result is small enough to fit into a \fCdouble\fP\&. The largest value of \fCn\fP for which \fCn!\fP < Double\&.MAX_VALUE is 170\&. If the computed value exceeds Double\&.MAX_VALUE, Double\&.POSITIVE_INFINITY is returned 
.PP
.PP
\fBParameters:\fP
.RS 4
\fIn\fP argument 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCn!\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIIllegalArgumentException\fP if n < 0 
.RE
.PP

.SS "static double org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.factorialLog (final intn)\fC [static]\fP"
Returns the natural logarithm of n!\&. 
.PP
\fBPreconditions\fP: 
.PD 0

.IP "\(bu" 2
\fCn >= 0\fP (otherwise \fCIllegalArgumentException\fP is thrown) 
.PP
.PP
\fBParameters:\fP
.RS 4
\fIn\fP argument 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCn!\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIIllegalArgumentException\fP if preconditions are not met\&. 
.RE
.PP

.SS "static int org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.gcd (intu, intv)\fC [static]\fP"
Gets the greatest common divisor of the absolute value of two numbers, using the 'binary gcd' method which avoids division and modulo operations\&. See Knuth 4\&.5\&.2 algorithm B\&. This algorithm is due to Josef Stein (1961)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIu\fP a non-zero number 
.br
\fIv\fP a non-zero number 
.RE
.PP
\fBReturns:\fP
.RS 4
the greatest common divisor, never zero 
.RE
.PP
\fBSince:\fP
.RS 4
1\&.1 
.RE
.PP

.SS "static int org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.hash (doublevalue)\fC [static]\fP"
Returns an integer hash code representing the given double value\&.
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP the value to be hashed 
.RE
.PP
\fBReturns:\fP
.RS 4
the hash code 
.RE
.PP

.SS "static int org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.hash (double[]value)\fC [static]\fP"
Returns an integer hash code representing the given double array value\&.
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP the value to be hashed (may be null) 
.RE
.PP
\fBReturns:\fP
.RS 4
the hash code 
.RE
.PP
\fBSince:\fP
.RS 4
1\&.2 
.RE
.PP

.SS "static byte org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.indicator (final bytex)\fC [static]\fP"
For a byte value x, this method returns (byte)(+1) if x >= 0 and (byte)(-1) if x < 0\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP the value, a byte 
.RE
.PP
\fBReturns:\fP
.RS 4
(byte)(+1) or (byte)(-1), depending on the sign of x 
.RE
.PP

.SS "static double org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.indicator (final doublex)\fC [static]\fP"
For a double precision value x, this method returns +1\&.0 if x >= 0 and -1\&.0 if x < 0\&. Returns \fCNaN\fP if \fCx\fP is \fCNaN\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP the value, a double 
.RE
.PP
\fBReturns:\fP
.RS 4
+1\&.0 or -1\&.0, depending on the sign of x 
.RE
.PP

.SS "static float org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.indicator (final floatx)\fC [static]\fP"
For a float value x, this method returns +1\&.0F if x >= 0 and -1\&.0F if x < 0\&. Returns \fCNaN\fP if \fCx\fP is \fCNaN\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP the value, a float 
.RE
.PP
\fBReturns:\fP
.RS 4
+1\&.0F or -1\&.0F, depending on the sign of x 
.RE
.PP

.SS "static int org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.indicator (final intx)\fC [static]\fP"
For an int value x, this method returns +1 if x >= 0 and -1 if x < 0\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP the value, an int 
.RE
.PP
\fBReturns:\fP
.RS 4
+1 or -1, depending on the sign of x 
.RE
.PP

.SS "static long org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.indicator (final longx)\fC [static]\fP"
For a long value x, this method returns +1L if x >= 0 and -1L if x < 0\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP the value, a long 
.RE
.PP
\fBReturns:\fP
.RS 4
+1L or -1L, depending on the sign of x 
.RE
.PP

.SS "static short org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.indicator (final shortx)\fC [static]\fP"
For a short value x, this method returns (short)(+1) if x >= 0 and (short)(-1) if x < 0\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP the value, a short 
.RE
.PP
\fBReturns:\fP
.RS 4
(short)(+1) or (short)(-1), depending on the sign of x 
.RE
.PP

.SS "static int org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.lcm (inta, intb)\fC [static]\fP"
Returns the least common multiple between two integer values\&.
.PP
\fBParameters:\fP
.RS 4
\fIa\fP the first integer value\&. 
.br
\fIb\fP the second integer value\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the least common multiple between a and b\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIArithmeticException\fP if the lcm is too large to store as an int 
.RE
.PP
\fBSince:\fP
.RS 4
1\&.1 
.RE
.PP

.SS "static double org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.log (doublebase, doublex)\fC [static]\fP"
Returns the \fClogarithm\fP for base \fCb\fP of \fCx\fP\&. 
.PP
Returns \fCNaN\fC if either argument is negative\&. If \fCbase\fP is 0 and \fCx\fP is positive, 0 is returned\&. If \fCbase\fP is positive and \fCx\fP is 0, \fCDouble\&.NEGATIVE_INFINITY\fP is returned\&. If both arguments are 0, the result is \fCNaN\fP\&.\fP\fP
.PP
\fC\fC\fP\fP
.PP
\fC\fC
.PP
\fBParameters:\fP
.RS 4
\fIbase\fP the base of the logarithm, must be greater than 0 
.br
\fIx\fP argument, must be greater than 0 
.RE
.PP
\fBReturns:\fP
.RS 4
the value of the logarithm - the number y such that base^y = x\&. 
.RE
.PP
\fBSince:\fP
.RS 4
1\&.2 
.RE
.PP
\fP\fP
.SS "static int org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.mulAndCheck (intx, inty)\fC [static]\fP"
Multiply two integers, checking for overflow\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP a factor 
.br
\fIy\fP a factor 
.RE
.PP
\fBReturns:\fP
.RS 4
the product \fCx*y\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIArithmeticException\fP if the result can not be represented as an int 
.RE
.PP
\fBSince:\fP
.RS 4
1\&.1 
.RE
.PP

.SS "static long org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.mulAndCheck (longa, longb)\fC [static]\fP"
Multiply two long integers, checking for overflow\&.
.PP
\fBParameters:\fP
.RS 4
\fIa\fP first value 
.br
\fIb\fP second value 
.RE
.PP
\fBReturns:\fP
.RS 4
the product \fCa * b\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIArithmeticException\fP if the result can not be represented as an long 
.RE
.PP
\fBSince:\fP
.RS 4
1\&.2 
.RE
.PP

.SS "static double org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.nextAfter (doubled, doubledirection)\fC [static]\fP"
Get the next machine representable number after a number, moving in the direction of another number\&. 
.PP
If \fCdirection\fP is greater than or equal to\fCd\fP, the smallest machine representable number strictly greater than \fCd\fP is returned; otherwise the largest representable number strictly less than \fCd\fP is returned\&.
.PP
If \fCd\fP is NaN or Infinite, it is returned unchanged\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP base number 
.br
\fIdirection\fP (the only important thing is whether direction is greater or smaller than d) 
.RE
.PP
\fBReturns:\fP
.RS 4
the next machine representable number in the specified direction 
.RE
.PP
\fBSince:\fP
.RS 4
1\&.2 
.RE
.PP

.SS "static double org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.normalizeAngle (doublea, doublecenter)\fC [static]\fP"
Normalize an angle in a 2&pi wide interval around a center value\&. 
.PP
This method has three main uses:
.PP
.PD 0
.IP "\(bu" 2
normalize an angle between 0 and 2:
.br
 \fCa = \fBMathUtils\&.normalizeAngle\fP(a, Math\&.PI);\fP 
.IP "\(bu" 2
normalize an angle between - and +
.br
 \fCa = \fBMathUtils\&.normalizeAngle\fP(a, 0\&.0);\fP 
.IP "\(bu" 2
compute the angle between two defining angular positions:
.br
 \fCangle = MathUtils\&.normalizeAngle(end, start) - start;\fP 
.PP
.PP
Note that due to numerical accuracy and since  cannot be represented exactly, the result interval is \fIclosed\fP, it cannot be half-closed as would be more satisfactory in a purely mathematical view\&.
.PP
\fBParameters:\fP
.RS 4
\fIa\fP angle to normalize 
.br
\fIcenter\fP center of the desired 2 interval for the result 
.RE
.PP
\fBReturns:\fP
.RS 4
a-2k with integer k and center- <= a-2k <= center+ 
.RE
.PP
\fBSince:\fP
.RS 4
1\&.2 
.RE
.PP

.SS "static double org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.round (doublex, intscale)\fC [static]\fP"
Round the given value to the specified number of decimal places\&. The value is rounded using the \fBBigDecimal#ROUND_HALF_UP\fP method\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP the value to round\&. 
.br
\fIscale\fP the number of digits to the right of the decimal point\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the rounded value\&. 
.RE
.PP
\fBSince:\fP
.RS 4
1\&.1 
.RE
.PP

.SS "static double org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.round (doublex, intscale, introundingMethod)\fC [static]\fP"
Round the given value to the specified number of decimal places\&. The value is rounded using the given method which is any method defined in \fBBigDecimal\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP the value to round\&. 
.br
\fIscale\fP the number of digits to the right of the decimal point\&. 
.br
\fIroundingMethod\fP the rounding method as defined in \fBBigDecimal\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the rounded value\&. 
.RE
.PP
\fBSince:\fP
.RS 4
1\&.1 
.RE
.PP

.SS "static float org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.round (floatx, intscale)\fC [static]\fP"
Round the given value to the specified number of decimal places\&. The value is rounding using the \fBBigDecimal#ROUND_HALF_UP\fP method\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP the value to round\&. 
.br
\fIscale\fP the number of digits to the right of the decimal point\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the rounded value\&. 
.RE
.PP
\fBSince:\fP
.RS 4
1\&.1 
.RE
.PP

.SS "static float org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.round (floatx, intscale, introundingMethod)\fC [static]\fP"
Round the given value to the specified number of decimal places\&. The value is rounded using the given method which is any method defined in \fBBigDecimal\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP the value to round\&. 
.br
\fIscale\fP the number of digits to the right of the decimal point\&. 
.br
\fIroundingMethod\fP the rounding method as defined in \fBBigDecimal\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the rounded value\&. 
.RE
.PP
\fBSince:\fP
.RS 4
1\&.1 
.RE
.PP

.SS "static byte org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.sign (final bytex)\fC [static]\fP"
Returns the \fCsign\fP for byte value \fCx\fP\&. 
.PP
For a byte value x, this method returns (byte)(+1) if x > 0, (byte)(0) if x = 0, and (byte)(-1) if x < 0\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP the value, a byte 
.RE
.PP
\fBReturns:\fP
.RS 4
(byte)(+1), (byte)(0), or (byte)(-1), depending on the sign of x 
.RE
.PP

.SS "static double org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.sign (final doublex)\fC [static]\fP"
Returns the \fCsign\fP for double precision \fCx\fP\&. 
.PP
For a double value \fCx\fP, this method returns \fC+1\&.0\fP if \fCx > 0\fP, \fC0\&.0\fP if \fCx = 0\&.0\fP, and \fC-1\&.0\fP if \fCx < 0\fP\&. Returns \fCNaN\fP if \fCx\fP is \fCNaN\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP the value, a double 
.RE
.PP
\fBReturns:\fP
.RS 4
+1\&.0, 0\&.0, or -1\&.0, depending on the sign of x 
.RE
.PP

.SS "static float org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.sign (final floatx)\fC [static]\fP"
Returns the \fCsign\fP for float value \fCx\fP\&. 
.PP
For a float value x, this method returns +1\&.0F if x > 0, 0\&.0F if x = 0\&.0F, and -1\&.0F if x < 0\&. Returns \fCNaN\fP if \fCx\fP is \fCNaN\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP the value, a float 
.RE
.PP
\fBReturns:\fP
.RS 4
+1\&.0F, 0\&.0F, or -1\&.0F, depending on the sign of x 
.RE
.PP

.SS "static int org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.sign (final intx)\fC [static]\fP"
Returns the \fCsign\fP for int value \fCx\fP\&. 
.PP
For an int value x, this method returns +1 if x > 0, 0 if x = 0, and -1 if x < 0\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP the value, an int 
.RE
.PP
\fBReturns:\fP
.RS 4
+1, 0, or -1, depending on the sign of x 
.RE
.PP

.SS "static long org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.sign (final longx)\fC [static]\fP"
Returns the \fCsign\fP for long value \fCx\fP\&. 
.PP
For a long value x, this method returns +1L if x > 0, 0L if x = 0, and -1L if x < 0\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP the value, a long 
.RE
.PP
\fBReturns:\fP
.RS 4
+1L, 0L, or -1L, depending on the sign of x 
.RE
.PP

.SS "static short org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.sign (final shortx)\fC [static]\fP"
Returns the \fCsign\fP for short value \fCx\fP\&. 
.PP
For a short value x, this method returns (short)(+1) if x > 0, (short)(0) if x = 0, and (short)(-1) if x < 0\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP the value, a short 
.RE
.PP
\fBReturns:\fP
.RS 4
(short)(+1), (short)(0), or (short)(-1), depending on the sign of x 
.RE
.PP

.SS "static double org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.sinh (doublex)\fC [static]\fP"
Returns the \fChyperbolic sine\fP of x\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP double value for which to find the hyperbolic sine 
.RE
.PP
\fBReturns:\fP
.RS 4
hyperbolic sine of x 
.RE
.PP

.SS "static int org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.subAndCheck (intx, inty)\fC [static]\fP"
Subtract two integers, checking for overflow\&.
.PP
\fBParameters:\fP
.RS 4
\fIx\fP the minuend 
.br
\fIy\fP the subtrahend 
.RE
.PP
\fBReturns:\fP
.RS 4
the difference \fCx-y\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIArithmeticException\fP if the result can not be represented as an int 
.RE
.PP
\fBSince:\fP
.RS 4
1\&.1 
.RE
.PP

.SS "static long org\&.apache\&.commons\&.math\&.util\&.MathUtils\&.subAndCheck (longa, longb)\fC [static]\fP"
Subtract two long integers, checking for overflow\&.
.PP
\fBParameters:\fP
.RS 4
\fIa\fP first value 
.br
\fIb\fP second value 
.RE
.PP
\fBReturns:\fP
.RS 4
the difference \fCa-b\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIArithmeticException\fP if the result can not be represented as an long 
.RE
.PP
\fBSince:\fP
.RS 4
1\&.2 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Desmo-J from the source code\&.
